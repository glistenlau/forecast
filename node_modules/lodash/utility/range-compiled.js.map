{"version":3,"sources":["range.js"],"names":[],"mappings":"AAAA,IAAI,cAAc,GAAG,OAAO,CAAC,4BAA4B,CAAC;;;AAAC,AAG3D,IAAI,UAAU,GAAG,IAAI,CAAC,IAAI;IACtB,SAAS,GAAG,IAAI,CAAC,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAC,AAmCzB,SAAS,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE;AAC/B,MAAI,IAAI,IAAI,cAAc,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE;AAC5C,OAAG,GAAG,IAAI,GAAG,SAAS,CAAC;GACxB;AACD,OAAK,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC;AACpB,MAAI,GAAG,IAAI,IAAI,IAAI,GAAG,CAAC,GAAI,CAAC,IAAI,IAAI,CAAC,AAAC,CAAC;;AAEvC,MAAI,GAAG,IAAI,IAAI,EAAE;AACf,OAAG,GAAG,KAAK,CAAC;AACZ,SAAK,GAAG,CAAC,CAAC;GACX,MAAM;AACL,OAAG,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;GACjB;;;AAAA,AAGD,MAAI,KAAK,GAAG,CAAC,CAAC;MACV,MAAM,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,GAAG,GAAG,KAAK,CAAA,IAAK,IAAI,IAAI,CAAC,CAAA,AAAC,CAAC,EAAE,CAAC,CAAC;MAC9D,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;;AAE3B,SAAO,EAAE,KAAK,GAAG,MAAM,EAAE;AACvB,UAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;AACtB,SAAK,IAAI,IAAI,CAAC;GACf;AACD,SAAO,MAAM,CAAC;CACf;;AAED,MAAM,CAAC,OAAO,GAAG,KAAK,CAAC","file":"range-compiled.js","sourcesContent":["var isIterateeCall = require('../internal/isIterateeCall');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. If `end` is not specified it's\n * set to `start` with `start` then set to `0`. If `end` is less than `start`\n * a zero-length range is created unless a negative `step` is specified.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the new array of numbers.\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nfunction range(start, end, step) {\n  if (step && isIterateeCall(start, end, step)) {\n    end = step = undefined;\n  }\n  start = +start || 0;\n  step = step == null ? 1 : (+step || 0);\n\n  if (end == null) {\n    end = start;\n    start = 0;\n  } else {\n    end = +end || 0;\n  }\n  // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\n  // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = start;\n    start += step;\n  }\n  return result;\n}\n\nmodule.exports = range;\n"]}