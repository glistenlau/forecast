{"version":3,"sources":["debounce.js"],"names":[],"mappings":"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","file":"debounce-compiled.js","sourcesContent":["var isObject = require('../lang/isObject'),\n    now = require('../date/now');\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed invocations. Provide an options object to indicate that `func`\n * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n * on the trailing edge of the timeout only if the the debounced function is\n * invoked more than once during the `wait` timeout.\n *\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.leading=false] Specify invoking on the leading\n *  edge of the timeout.\n * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n *  delayed before it's invoked.\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n *  edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // avoid costly calculations while the window size is in flux\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // ensure `batchLog` is invoked once after 1 second of debounced calls\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', _.debounce(batchLog, 250, {\n *   'maxWait': 1000\n * }));\n *\n * // cancel a debounced call\n * var todoChanges = _.debounce(batchLog, 1000);\n * Object.observe(models.todo, todoChanges);\n *\n * Object.observe(models, function(changes) {\n *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n *     todoChanges.cancel();\n *   }\n * }, ['delete']);\n *\n * // ...at some point `models.todo` is changed\n * models.todo.completed = true;\n *\n * // ...before 1 second has passed `models.todo` is deleted\n * // which cancels the debounced `todoChanges` call\n * delete models.todo;\n */\nfunction debounce(func, wait, options) {\n  var args,\n      maxTimeoutId,\n      result,\n      stamp,\n      thisArg,\n      timeoutId,\n      trailingCall,\n      lastCalled = 0,\n      maxWait = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = wait < 0 ? 0 : (+wait || 0);\n  if (options === true) {\n    var leading = true;\n    trailing = false;\n  } else if (isObject(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    if (maxTimeoutId) {\n      clearTimeout(maxTimeoutId);\n    }\n    lastCalled = 0;\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n  }\n\n  function complete(isCalled, id) {\n    if (id) {\n      clearTimeout(id);\n    }\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n    if (isCalled) {\n      lastCalled = now();\n      result = func.apply(thisArg, args);\n      if (!timeoutId && !maxTimeoutId) {\n        args = thisArg = undefined;\n      }\n    }\n  }\n\n  function delayed() {\n    var remaining = wait - (now() - stamp);\n    if (remaining <= 0 || remaining > wait) {\n      complete(trailingCall, maxTimeoutId);\n    } else {\n      timeoutId = setTimeout(delayed, remaining);\n    }\n  }\n\n  function maxDelayed() {\n    complete(trailing, timeoutId);\n  }\n\n  function debounced() {\n    args = arguments;\n    stamp = now();\n    thisArg = this;\n    trailingCall = trailing && (timeoutId || !leading);\n\n    if (maxWait === false) {\n      var leadingCall = leading && !timeoutId;\n    } else {\n      if (!maxTimeoutId && !leading) {\n        lastCalled = stamp;\n      }\n      var remaining = maxWait - (stamp - lastCalled),\n          isCalled = remaining <= 0 || remaining > maxWait;\n\n      if (isCalled) {\n        if (maxTimeoutId) {\n          maxTimeoutId = clearTimeout(maxTimeoutId);\n        }\n        lastCalled = stamp;\n        result = func.apply(thisArg, args);\n      }\n      else if (!maxTimeoutId) {\n        maxTimeoutId = setTimeout(maxDelayed, remaining);\n      }\n    }\n    if (isCalled && timeoutId) {\n      timeoutId = clearTimeout(timeoutId);\n    }\n    else if (!timeoutId && wait !== maxWait) {\n      timeoutId = setTimeout(delayed, wait);\n    }\n    if (leadingCall) {\n      isCalled = true;\n      result = func.apply(thisArg, args);\n    }\n    if (isCalled && !timeoutId && !maxTimeoutId) {\n      args = thisArg = undefined;\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  return debounced;\n}\n\nmodule.exports = debounce;\n"]}