{"version":3,"sources":["binaryIndexBy.js"],"names":[],"mappings":";AACA,IAAI,WAAW,GAAG,IAAI,CAAC,KAAK;IACxB,SAAS,GAAG,IAAI,CAAC,GAAG;;;AAAC,AAGzB,IAAI,gBAAgB,GAAG,UAAU;IAC7B,eAAe,GAAG,gBAAgB,GAAG,CAAC;;;;;;;;;;;;;;;AAAC,AAe3C,SAAS,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE;AACzD,OAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;;AAExB,MAAI,GAAG,GAAG,CAAC;MACP,IAAI,GAAG,KAAK,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC;MAC/B,QAAQ,GAAG,KAAK,KAAK,KAAK;MAC1B,SAAS,GAAG,KAAK,KAAK,IAAI;MAC1B,UAAU,GAAG,KAAK,KAAK,SAAS,CAAC;;AAErC,SAAO,GAAG,GAAG,IAAI,EAAE;AACjB,QAAI,GAAG,GAAG,WAAW,CAAC,CAAC,GAAG,GAAG,IAAI,CAAA,GAAI,CAAC,CAAC;QACnC,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC/B,KAAK,GAAG,QAAQ,KAAK,SAAS;QAC9B,WAAW,GAAG,QAAQ,KAAK,QAAQ,CAAC;;AAExC,QAAI,QAAQ,EAAE;AACZ,UAAI,MAAM,GAAG,WAAW,IAAI,UAAU,CAAC;KACxC,MAAM,IAAI,SAAS,EAAE;AACpB,YAAM,GAAG,WAAW,IAAI,KAAK,KAAK,UAAU,IAAI,QAAQ,IAAI,IAAI,CAAA,AAAC,CAAC;KACnE,MAAM,IAAI,UAAU,EAAE;AACrB,YAAM,GAAG,WAAW,KAAK,UAAU,IAAI,KAAK,CAAA,AAAC,CAAC;KAC/C,MAAM,IAAI,QAAQ,IAAI,IAAI,EAAE;AAC3B,YAAM,GAAG,KAAK,CAAC;KAChB,MAAM;AACL,YAAM,GAAG,UAAU,GAAI,QAAQ,IAAI,KAAK,GAAK,QAAQ,GAAG,KAAK,AAAC,CAAC;KAChE;AACD,QAAI,MAAM,EAAE;AACV,SAAG,GAAG,GAAG,GAAG,CAAC,CAAC;KACf,MAAM;AACL,UAAI,GAAG,GAAG,CAAC;KACZ;GACF;AACD,SAAO,SAAS,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;CACzC;;AAED,MAAM,CAAC,OAAO,GAAG,aAAa,CAAC","file":"binaryIndexBy-compiled.js","sourcesContent":["/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeMin = Math.min;\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/**\n * This function is like `binaryIndex` except that it invokes `iteratee` for\n * `value` and each element of `array` to compute their sort ranking. The\n * iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction binaryIndexBy(array, value, iteratee, retHighest) {\n  value = iteratee(value);\n\n  var low = 0,\n      high = array ? array.length : 0,\n      valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsUndef = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        isDef = computed !== undefined,\n        isReflexive = computed === computed;\n\n    if (valIsNaN) {\n      var setLow = isReflexive || retHighest;\n    } else if (valIsNull) {\n      setLow = isReflexive && isDef && (retHighest || computed != null);\n    } else if (valIsUndef) {\n      setLow = isReflexive && (retHighest || isDef);\n    } else if (computed == null) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? (computed <= value) : (computed < value);\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\nmodule.exports = binaryIndexBy;\n"]}