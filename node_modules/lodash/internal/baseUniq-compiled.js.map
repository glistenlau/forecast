{"version":3,"sources":["baseUniq.js"],"names":[],"mappings":"AAAA,IAAI,WAAW,GAAG,OAAO,CAAC,eAAe,CAAC;IACtC,YAAY,GAAG,OAAO,CAAC,gBAAgB,CAAC;IACxC,WAAW,GAAG,OAAO,CAAC,eAAe,CAAC;;;AAAC,AAG3C,IAAI,gBAAgB,GAAG,GAAG;;;;;;;;;;;AAAC,AAW3B,SAAS,QAAQ,CAAC,KAAK,EAAE,QAAQ,EAAE;AACjC,MAAI,KAAK,GAAG,CAAC,CAAC;MACV,OAAO,GAAG,WAAW;MACrB,MAAM,GAAG,KAAK,CAAC,MAAM;MACrB,QAAQ,GAAG,IAAI;MACf,OAAO,GAAG,QAAQ,IAAI,MAAM,IAAI,gBAAgB;MAChD,IAAI,GAAG,OAAO,GAAG,WAAW,EAAE,GAAG,IAAI;MACrC,MAAM,GAAG,EAAE,CAAC;;AAEhB,MAAI,IAAI,EAAE;AACR,WAAO,GAAG,YAAY,CAAC;AACvB,YAAQ,GAAG,KAAK,CAAC;GAClB,MAAM;AACL,WAAO,GAAG,KAAK,CAAC;AAChB,QAAI,GAAG,QAAQ,GAAG,EAAE,GAAG,MAAM,CAAC;GAC/B;AACD,OAAK,EACL,OAAO,EAAE,KAAK,GAAG,MAAM,EAAE;AACvB,QAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;QACpB,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC;;AAEhE,QAAI,QAAQ,IAAI,KAAK,KAAK,KAAK,EAAE;AAC/B,UAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;AAC5B,aAAO,SAAS,EAAE,EAAE;AAClB,YAAI,IAAI,CAAC,SAAS,CAAC,KAAK,QAAQ,EAAE;AAChC,mBAAS,KAAK,CAAC;SAChB;OACF;AACD,UAAI,QAAQ,EAAE;AACZ,YAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;OACrB;AACD,YAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACpB,MACI,IAAI,OAAO,CAAC,IAAI,EAAE,QAAQ,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE;AACvC,UAAI,QAAQ,IAAI,OAAO,EAAE;AACvB,YAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;OACrB;AACD,YAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACpB;GACF;AACD,SAAO,MAAM,CAAC;CACf;;AAED,MAAM,CAAC,OAAO,GAAG,QAAQ,CAAC","file":"baseUniq-compiled.js","sourcesContent":["var baseIndexOf = require('./baseIndexOf'),\n    cacheIndexOf = require('./cacheIndexOf'),\n    createCache = require('./createCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniq` without support for callback shorthands\n * and `this` binding.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The function invoked per iteration.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee) {\n  var index = -1,\n      indexOf = baseIndexOf,\n      length = array.length,\n      isCommon = true,\n      isLarge = isCommon && length >= LARGE_ARRAY_SIZE,\n      seen = isLarge ? createCache() : null,\n      result = [];\n\n  if (seen) {\n    indexOf = cacheIndexOf;\n    isCommon = false;\n  } else {\n    isLarge = false;\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value, index, array) : value;\n\n    if (isCommon && value === value) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (indexOf(seen, computed, 0) < 0) {\n      if (iteratee || isLarge) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n"]}